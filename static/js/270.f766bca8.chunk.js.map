{"version":3,"sources":["../node_modules/prismjs/components/prism-naniscript.js"],"names":["Prism","expressionDef","params","pattern","alias","lookbehind","greedy","getTextContent","token","Array","isArray","map","join","content","languages","naniscript","inside","nani","hooks","add","env","tokens","forEach","type","input","brackets","stack","i","length","bracket","bracketsIndex","indexOf","push","pop","isBracketsBalanced"],"mappings":"wHAAA,SAAWA,GAEV,IAAIC,EAAgB,qBAEhBC,EAAS,CACZ,gBAAiB,CAChBC,QAAS,oBACTC,MAAO,YAER,mBAAoB,CACnBD,QAAS,WACTE,YAAY,EACZD,MAAO,YAER,sBAAuB,CACtB,CACCD,QAASF,EACTG,MAAO,YAER,CACCD,QAAS,aACTE,YAAY,EACZC,QAAQ,EACRF,MAAO,YAER,CACCD,QAAS,cACTC,MAAO,cAoIV,SAASG,EAAeC,GACvB,MAAqB,kBAAVA,EACHA,EACGC,MAAMC,QAAQF,GACjBA,EAAMG,IAAIJ,GAAgBK,KAAK,IAE/BL,EAAeC,EAAMK,SArI9Bb,EAAMc,UAAUC,WAAa,CAE5B,QAAW,CACVZ,QAAS,gBACTE,YAAY,GAIb,OAAU,CACTF,QAAS,QACTC,MAAO,MACPY,OAAQ,CACP,MAAS,CACRb,QAAS,gCACTE,YAAY,EACZD,MAAO,YAER,IAAO,CACND,QAAS,UACTE,YAAY,KAKf,MAAS,CACRF,QAAS,8BACTE,YAAY,EACZD,MAAO,SAER,QAAW,CACVD,QAAS,8BACTE,YAAY,EACZD,MAAO,WACPY,OAAQ,CACP,eAAgB,QAChB,WAAc,CACbb,QAASF,EACTK,QAAQ,EACRF,MAAO,YAER,iBAAkB,CACjBD,QAAS,mBACTa,OAAQd,KAKX,eAAgB,CACfC,QAAS,wBACTE,YAAY,EACZD,MAAO,cACPY,OAAQ,CAEP,eAAgB,cAChB,WAAc,CACbb,QAASF,EACTK,QAAQ,EACRF,MAAO,YAER,iBAAkB,CACjBD,QAAS,4BACTG,QAAQ,EACRF,MAAO,WACPY,OAAQ,CACP,iBAAkB,CACjBb,QAAS,iCACTE,YAAY,EACZW,OAAQd,GAET,qBAAsB,CACrBC,QAAS,iBACTE,YAAY,EACZD,MAAO,QAER,kBAAmB,cAMxBJ,EAAMc,UAAUG,KAAOjB,EAAMc,UAAN,WAQvBd,EAAMkB,MAAMC,IAAI,kBAAkB,SAAUC,GAE9BA,EAAIC,OACVC,SAAQ,SAAUd,GACxB,GAAqB,kBAAVA,GAAqC,iBAAfA,EAAMe,KAAyB,CAC/D,IAAIV,EAAUN,EAAeC,IAahC,SAA4BgB,GAG3B,IAFA,IAAIC,EAAW,OACXC,EAAQ,GACHC,EAAI,EAAGA,EAAIH,EAAMI,OAAQD,IAAK,CACtC,IAAIE,EAAUL,EAAMG,GAChBG,EAAgBL,EAASM,QAAQF,GACrC,IAAuB,IAAnBC,EACH,GAAIA,EAAgB,IAAM,EACzBJ,EAAMM,KAAKF,EAAgB,QACrB,GAAIJ,EAAMO,QAAUH,EAC1B,OAAO,EAIV,OAAwB,IAAjBJ,EAAME,QA1BNM,CAAmBrB,KACvBL,EAAMe,KAAO,WACbf,EAAMK,QAAUA,UAhIrB,CAyKGb","file":"static/js/270.f766bca8.chunk.js","sourcesContent":["(function (Prism) {\n\n\tvar expressionDef = /\\{[^\\r\\n\\[\\]{}]*\\}/;\n\n\tvar params = {\n\t\t'quoted-string': {\n\t\t\tpattern: /\"(?:[^\"\\\\]|\\\\.)*\"/,\n\t\t\talias: 'operator'\n\t\t},\n\t\t'command-param-id': {\n\t\t\tpattern: /(\\s)\\w+:/,\n\t\t\tlookbehind: true,\n\t\t\talias: 'property'\n\t\t},\n\t\t'command-param-value': [\n\t\t\t{\n\t\t\t\tpattern: expressionDef,\n\t\t\t\talias: 'selector',\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /([\\t ])\\S+/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tgreedy: true,\n\t\t\t\talias: 'operator',\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /\\S(?:.*\\S)?/,\n\t\t\t\talias: 'operator',\n\t\t\t}\n\t\t]\n\t};\n\n\tPrism.languages.naniscript = {\n\t\t// ; ...\n\t\t'comment': {\n\t\t\tpattern: /^([\\t ]*);.*/m,\n\t\t\tlookbehind: true,\n\t\t},\n\t\t// > ...\n\t\t// Define is a control line starting with '>' followed by a word, a space and a text.\n\t\t'define': {\n\t\t\tpattern: /^>.+/m,\n\t\t\talias: 'tag',\n\t\t\tinside: {\n\t\t\t\t'value': {\n\t\t\t\t\tpattern: /(^>\\w+[\\t ]+)(?!\\s)[^{}\\r\\n]+/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\talias: 'operator'\n\t\t\t\t},\n\t\t\t\t'key': {\n\t\t\t\t\tpattern: /(^>)\\w+/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t// # ...\n\t\t'label': {\n\t\t\tpattern: /^([\\t ]*)#[\\t ]*\\w+[\\t ]*$/m,\n\t\t\tlookbehind: true,\n\t\t\talias: 'regex'\n\t\t},\n\t\t'command': {\n\t\t\tpattern: /^([\\t ]*)@\\w+(?=[\\t ]|$).*/m,\n\t\t\tlookbehind: true,\n\t\t\talias: 'function',\n\t\t\tinside: {\n\t\t\t\t'command-name': /^@\\w+/,\n\t\t\t\t'expression': {\n\t\t\t\t\tpattern: expressionDef,\n\t\t\t\t\tgreedy: true,\n\t\t\t\t\talias: 'selector'\n\t\t\t\t},\n\t\t\t\t'command-params': {\n\t\t\t\t\tpattern: /[\\s\\S]*\\S[\\s\\S]*/,\n\t\t\t\t\tinside: params\n\t\t\t\t},\n\t\t\t}\n\t\t},\n\t\t// Generic is any line that doesn't start with operators: ;>#@\n\t\t'generic-text': {\n\t\t\tpattern: /(^[ \\t]*)[^#@>;\\s].*/m,\n\t\t\tlookbehind: true,\n\t\t\talias: 'punctuation',\n\t\t\tinside: {\n\t\t\t\t// \\{ ... \\} ... \\[ ... \\] ... \\\"\n\t\t\t\t'escaped-char': /\\\\[{}\\[\\]\"]/,\n\t\t\t\t'expression': {\n\t\t\t\t\tpattern: expressionDef,\n\t\t\t\t\tgreedy: true,\n\t\t\t\t\talias: 'selector'\n\t\t\t\t},\n\t\t\t\t'inline-command': {\n\t\t\t\t\tpattern: /\\[[\\t ]*\\w+[^\\r\\n\\[\\]]*\\]/,\n\t\t\t\t\tgreedy: true,\n\t\t\t\t\talias: 'function',\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t'command-params': {\n\t\t\t\t\t\t\tpattern: /(^\\[[\\t ]*\\w+\\b)[\\s\\S]+(?=\\]$)/,\n\t\t\t\t\t\t\tlookbehind: true,\n\t\t\t\t\t\t\tinside: params\n\t\t\t\t\t\t},\n\t\t\t\t\t\t'command-param-name': {\n\t\t\t\t\t\t\tpattern: /^(\\[[\\t ]*)\\w+/,\n\t\t\t\t\t\t\tlookbehind: true,\n\t\t\t\t\t\t\talias: 'name',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t'start-stop-char': /[\\[\\]]/,\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t};\n\tPrism.languages.nani = Prism.languages['naniscript'];\n\n\t/** @typedef {InstanceType<import(\"./prism-core\")[\"Token\"]>} Token */\n\n\t/**\n\t * This hook is used to validate generic-text tokens for balanced brackets.\n\t * Mark token as bad-line when contains not balanced brackets: {},[]\n\t */\n\tPrism.hooks.add('after-tokenize', function (env) {\n\t\t/** @type {(Token | string)[]} */\n\t\tvar tokens = env.tokens;\n\t\ttokens.forEach(function (token) {\n\t\t\tif (typeof token !== \"string\" && token.type === 'generic-text') {\n\t\t\t\tvar content = getTextContent(token);\n\t\t\t\tif (!isBracketsBalanced(content)) {\n\t\t\t\t\ttoken.type = 'bad-line';\n\t\t\t\t\ttoken.content = content;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n\n\t/**\n\t * @param {string} input\n\t * @returns {boolean}\n\t */\n\tfunction isBracketsBalanced(input) {\n\t\tvar brackets = \"[]{}\";\n\t\tvar stack = [];\n\t\tfor (var i = 0; i < input.length; i++) {\n\t\t\tvar bracket = input[i];\n\t\t\tvar bracketsIndex = brackets.indexOf(bracket);\n\t\t\tif (bracketsIndex !== -1) {\n\t\t\t\tif (bracketsIndex % 2 === 0) {\n\t\t\t\t\tstack.push(bracketsIndex + 1);\n\t\t\t\t} else if (stack.pop() !== bracketsIndex) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn stack.length === 0;\n\t};\n\n\t/**\n\t * @param {string | Token | (string | Token)[]} token\n\t * @returns {string}\n\t */\n\tfunction getTextContent(token) {\n\t\tif (typeof token === 'string') {\n\t\t\treturn token;\n\t\t} else if (Array.isArray(token)) {\n\t\t\treturn token.map(getTextContent).join('');\n\t\t} else {\n\t\t\treturn getTextContent(token.content);\n\t\t}\n\t}\n\n})(Prism);\n"],"sourceRoot":""}